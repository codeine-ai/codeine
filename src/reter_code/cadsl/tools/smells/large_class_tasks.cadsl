# large_class_tasks - Detect large classes and create review tasks
#
# Based on Martin Fowler's "Refactoring" Chapter 3, Smell #3
# "When a class is trying to do too much, it often shows up as
# too many instance variables."
#
# Creates tasks for human review and classification (TP/FP).

detector large_class_tasks(category="smell-review", severity="high") {
    """
    Find classes exceeding size thresholds and create review tasks.

    Each task requires manual classification:
    - TP: Class has multiple responsibilities, needs Extract Class
    - FP-FRAMEWORK: Framework requires consolidated class (ANTLR visitors, ORM)
    - FP-PROTOCOL: Interface contract requires all methods (ABC impl)
    - FP-DOMAIN-MODEL: Domain genuinely has many attributes
    - FP-GENERATED: Auto-generated code (Protobuf, gRPC)
    - FP-INTENTIONAL: Performance optimization (avoid indirection)

    Parameters:
        max_methods: Maximum methods before flagging (default: 20)
        max_fields: Maximum fields before flagging (default: 10)
        limit: Maximum tasks to create (default: 50)
        dry_run: If true, preview without creating tasks (default: true)
    """

    param max_methods: int = 20;
    param max_fields: int = 10;
    param limit: int = 50;
    param dry_run: bool = true;

    # Get classes with method counts
    reql {
        SELECT ?c ?name ?file ?line (COUNT(?method) AS ?method_count)
        WHERE {
            ?c type class .
            ?c has-name ?name .
            ?c is-in-file ?file .
            ?c is-at-line ?line .
            ?method type method .
            ?method is-defined-in ?c .
            FILTER (!CONTAINS(?file, "test"))
            FILTER (!CONTAINS(?file, "tests"))
            FILTER (!CONTAINS(?file, "_test.py"))
            FILTER (!CONTAINS(?file, "test_"))
        }
        GROUP BY ?c ?name ?file ?line
        ORDER BY DESC(?method_count)
    }
    | join {
        on: name,
        right: reql {
            SELECT ?name (COUNT(?field) AS ?field_count)
            WHERE {
                ?c type class .
                ?c has-name ?name .
                ?field type field .
                ?field is-defined-in ?c
            }
            GROUP BY ?name
        },
        type: left
    }
    | map {
        name: name,
        file: file,
        line: line,
        method_count: method_count,
        field_count: field_count ?? 0
    }
    | filter { method_count > {max_methods} || field_count > {max_fields} }
    | order_by { -method_count }
    | limit { {limit} }
    | create_task {
        name: "[large_class] {name} ({field_count} fields, {method_count} methods) in {file}",
        category: "smell-review",
        priority: high,
        description: "**Large Class detected** - requires classification.\n\n**Class**: `{name}`\n**Location**: {file}:{line}\n**Fields**: {field_count}\n**Methods**: {method_count}\n\n---\n\n## Classification (Check FP First!)\n\n**Step 1: Rule out False Positives**\n\n| Check | Question | If Yes → |\n|-------|----------|----------|\n| FP-FRAMEWORK | Is this an ANTLR visitor, ORM model, or framework class? | Close as FP |\n| FP-PROTOCOL | Does an ABC/interface require all these methods? | Close as FP |\n| FP-DOMAIN-MODEL | Is this a rich domain entity (Customer, Order)? | Close as FP |\n| FP-GENERATED | Is this auto-generated (Protobuf, gRPC stubs)? | Close as FP |\n| FP-INTENTIONAL | Is consolidation for performance (hot path)? | Close as FP |\n\n**Step 2: If no FP criteria met → TRUE POSITIVE**\n\nProceed with extraction planning below.\n\n---\n\n## If TP - Analysis Steps\n\n1. **Identify field clusters**: Look for common prefixes (order_*, customer_*)\n2. **Identify method clusters**: Which methods use which fields?\n3. **Find client usage patterns**: Do different clients use different subsets?\n4. **Plan extractions**: Name the classes to extract\n\n## Extraction Candidates\n\n- Value objects (groups of related data)\n- Strategy objects (algorithm variations)\n- State objects (state-specific behavior)\n- Helper/utility clusters\n\n---\n\n## Refactorings\n\n| Refactoring | When to Use |\n|-------------|-------------|\n| Extract Class | Subset of fields/methods form cohesive unit |\n| Extract Subclass | Subset of features used in some instances |\n| Extract Interface | Clients use different views of class |\n| Duplicate Observed Data | GUI class mixed with domain logic |",
        affects: file,
        dry_run: {dry_run}
    }
    | emit { tasks }
}
