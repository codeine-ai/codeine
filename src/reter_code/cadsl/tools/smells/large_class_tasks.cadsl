# large_class_tasks - Detect large classes and create review tasks
#
# Based on Martin Fowler's "Refactoring" Chapter 3, Smell #3
# "When a class is trying to do too much, it often shows up as
# too many instance variables."
#
# Creates tasks for human review and classification (TP/FP).

detector large_class_tasks(category="smell-review", severity="high") {
    """
    Find classes exceeding size thresholds and create review tasks.

    Each task requires manual classification:
    - TP: Class has multiple responsibilities, needs Extract Class
    - FP-FRAMEWORK: Framework requires consolidated class (ANTLR visitors, ORM)
    - FP-PROTOCOL: Interface contract requires all methods (ABC impl)
    - FP-DOMAIN-MODEL: Domain genuinely has many attributes
    - FP-GENERATED: Auto-generated code (Protobuf, gRPC)
    - FP-INTENTIONAL: Performance optimization (avoid indirection)

    Parameters:
        max_methods: Maximum methods before flagging (default: 20)
        max_fields: Maximum fields before flagging (default: 10)
        limit: Maximum tasks to create (default: 50)
        dry_run: If true, preview without creating tasks (default: true)
    """

    param max_methods: int = 20;
    param max_fields: int = 10;
    param limit: int = 50;
    param dry_run: bool = true;

    # Get classes with method counts
    reql {
        SELECT ?c ?name ?file ?line (COUNT(?method) AS ?method_count)
        WHERE {
            ?c type class .
            ?c has-name ?name .
            ?c is-in-file ?file .
            ?c is-at-line ?line .
            ?method type method .
            ?method is-defined-in ?c .
            FILTER (!CONTAINS(?file, "test"))
            FILTER (!CONTAINS(?file, "tests"))
            FILTER (!CONTAINS(?file, "_test.py"))
            FILTER (!CONTAINS(?file, "test_"))
        }
        GROUP BY ?c ?name ?file ?line
        ORDER BY DESC(?method_count)
    }
    | join {
        on: name,
        right: reql {
            SELECT ?name (COUNT(?field) AS ?field_count)
            WHERE {
                ?c type class .
                ?c has-name ?name .
                ?field type field .
                ?field is-defined-in ?c
            }
            GROUP BY ?name
        },
        type: left
    }
    | map {
        name: name,
        file: file,
        line: line,
        method_count: method_count,
        field_count: field_count ?? 0
    }
    | filter { method_count > {max_methods} || field_count > {max_fields} }
    | order_by { -method_count }
    | limit { {limit} }
    | create_task {
        name: "[large_class] {name} ({field_count} fields, {method_count} methods) in {file}",
        category: "smell-review",
        priority: high,
        description: "**Large Class detected** - requires CODE ANALYSIS before classification.\n\n**Class**: `{name}`\n**Location**: {file}:{line}\n**Fields**: {field_count}\n**Methods**: {method_count}\n\n---\n\n## ⚠️ CRITICAL: Read the Code First!\n\n**You MUST read the actual class code before classifying!**\n\n```python\n# ALWAYS read the file first - never classify based on class name alone!\nRead(file_path=\"{file}\")\n```\n\n**What to look for:**\n- What does the class actually do? (Read the methods!)\n- Are fields grouped by concern? (Look for prefixes like order_*, customer_*)\n- Does it implement an interface/ABC? (Check inheritance)\n- Is there a \"generated by\" comment?\n- Are methods cohesive or doing different things?\n\n---\n\n## Classification (After Reading Code!)\n\n**Step 1: Rule out False Positives** (based on actual code analysis)\n\n| Check | Question | How to Verify |\n|-------|----------|---------------|\n| FP-FRAMEWORK | ANTLR visitor, ORM model? | Check base class, visit* methods |\n| FP-PROTOCOL | ABC/interface requires methods? | Check inheritance, @abstractmethod |\n| FP-DOMAIN-MODEL | Rich domain entity? | Check if fields represent real domain |\n| FP-GENERATED | Auto-generated code? | Look for generator comments |\n| FP-INTENTIONAL | Performance consolidation? | Check if hot path, avoid indirection |\n\n**Step 2: If no FP criteria met → TRUE POSITIVE**\n\n---\n\n## If TP - Analysis Steps (from code analysis)\n\n1. **Identify field clusters**: Look for common prefixes (order_*, customer_*)\n2. **Identify method clusters**: Which methods use which fields?\n3. **Find client usage patterns**: Do different clients use different subsets?\n4. **Plan extractions**: Name the classes to extract\n\n## Extraction Candidates\n\n- Value objects (groups of related data)\n- Strategy objects (algorithm variations)\n- State objects (state-specific behavior)\n- Helper/utility clusters\n\n---\n\n## Refactorings\n\n| Refactoring | When to Use |\n|-------------|-------------|\n| Extract Class | Subset of fields/methods form cohesive unit |\n| Extract Subclass | Subset of features used in some instances |\n| Extract Interface | Clients use different views of class |",
        affects: file,
        dry_run: {dry_run}
    }
    | emit { tasks }
}
